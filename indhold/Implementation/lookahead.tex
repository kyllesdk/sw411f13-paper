\section{Lookahead}
A programming language can in some cases requre a feature called lookahead. This feature allows for choosing the right path in a grammar where it is not possible to determine the correct outcome immediatly. Such points leading to different paths can for example be represented by brackets in the grammar which are optional parts. A part of a grammar could be $"a" "b" ["c"]$. In this case the parser will first look for "a", then for "b". Then it has to decide whether it is done reading (The string is $ab$) or if it should continue, making the string $abc$. Assuming that the string $abc$ is matched, what if the caller of this grammar function now requires a $"c"$? The parser will then have made a mistake in matching $abc$ too early and must backtrace all the way to the choice point to take the other option. Backtracing is however inefficient and undesirable which is where lookahead comes in. Instead of blindly choosing one path over another lookahead allows to look ahead in the grammar and make qualified decisions. JavaCC uses this feature and does not backtrace \todo{Morten: Source needed}. By default lookahead(1) is used which is also what we stick to in our grammar. While lookahead is more efficient than backtracking it can still be very inefficient. As such we have made our grammar efficient in regards to lookahead and actually the lookahead(1) is only used in our if-else grammar. In the if-else grammar, the if part will be read first. After this however, the parser has to decide between whether the next part is an elseif or an else.\todo{Morten: Need verification/clarification}