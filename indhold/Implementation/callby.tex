\section{Call-by methods}
There are three different methods for parsing parameter to functions, these are, call-by-value, call-by-reference and call-by-name. It is possible to implement more then one of these methods.

\subsection*{Implementation}To keep it simple and easy for the user, only the call-by-value method will be implemented in BAL. This will allow for passing of parameters to functions, while keeping it simple. By not including features like pointers, the user will not be confused with more than one way of accomplishing a certain task.

\subsection*{Call-by-reference}
With call-by-reference, $func(a)$, $a$ is the address of the parameter. So consider the following example;
\begin{lstlisting}[caption=call-by-reference example, label=lst:call-by-ref]
y = 0;

func(y){
	y + 1;
}
\end{lstlisting}
Since it is the location of $y$ that is passed, the value of $y$ after the function call will be incremented by 1.
\subsection*{Call-by-value}
With call-by-value, as opposed to call-by-reference, the value is copied to a local variable in the function, rather then using the original parameter. If using the example above code \ref{lst:call-by-ref}, the value of $y$ after the function call will still be $0$. Since it is only the value that  is copied, it is also possible to make calls, using arithmetic expressions, if $y+1$ is passed instead of $y$, then the result of the expression $1$ will be passed.
\subsection*{Call-by-name}
This method allows the passing of expressions without evaluating them. Call-by-name is less obvious than call-by-value and call-by-reference. Using the previous example with call-by-value, passing $y+1$ would be evaluated first and then passed as $1$. Call-by-name is different in that it passes the expression itself. The expression will not be evaluated until it is accessed in the function. Furthermore it will be evaluated on every call. As such the pass to the function holds $y+1$, and only when accessed will the expression be evaluated to $1$. Unique to call-by-name, this evaluation happens every time it is accessed. This allows $y$ to be evaluated correctly every time, even if it should somehow be assigned to a new value.
