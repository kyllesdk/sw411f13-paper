% \section{Syntax}
% When describing a programming language the syntax of the language is the set of rules which define the character combinations allowed when writing a program in that language. To define the syntax of a language regular expressions are being used, which specifies what strings are recognized in the language. The syntax of the language is also described via Backus-Naur Form, short BNF, that describes the context free grammar of the language with non-terminal and terminal symbols.



% In this report an extended version of BNF, also called EBNF(Extended Backus-Naur Form), is used. EBNF is used because it can be used to describe the same set of rules, but in fewer lines. EBNF do not enhance the descriptive power of BNF, it only increases the readability and write-ability.

%\subsection{Program}
% \begin{lstlisting}[captionpos=b, caption{EBNF of how a program needs to be structured.}]
% <program> -> void setup() begin <statement_list> end void loop() begin <statement_list> end
% <statement_list> -> (<statement> | <statement> ; <statement_list>
% \end{lstlisting}

% \subsection{IF-statement}
% The following EBNF describes how IF-statements can be used in the source language. It describes that the if-statement can be used in one of the three different ways:
% \begin{itemize}
% 	\item if(EXPRESSION) then STATEMENT end
% 	\item if(EXPRESSION) then STATEMENT elseif STATEMENT else STATEMENT end. The elseif statement can be used an infinite amount of times.
% 	\item If(EXPRESSION) then STATEMENT else STATEMENT end
% \end{itemize}
% \begin{lstlisting}[captionpos=b, caption={EBNF of the IF-statement in the source language}]
% <if_statement> -> if(<expression>) then <statement> [{elseif <statement>} else <statement> | else <statement>] end
% \end{lstlisting}


% \subsection{While loop}
% The following EBNF describes how the while loop is allowed to be used in the source language. Note that only a while loop is described, because no other loops than the while loop is part of the source language.
% \begin{lstlisting}[mathescape, captionpos=b, caption={EBNF of a while loop.}]
% <while_stmt> -> while (<expression>) do <statement> end
% \end{lstlisting}

% \subsection{Function}
% \begin{lstlisting}[mathescape, captionpos=b, caption={EBNF of a function.}]
% <function> -> function (<expression>) do <statement> end
% \end{lstlisting}

% \subsection{Assign}
% \begin{lstlisting}[mathescape, captionpos=b, caption{EBNF of how assignment work.}]
% <assign> -> <variable> = <expression>;
% \end{lstlisting}

% \subsection{Variables}
% \begin{lstlisting}[mathescape, captionpos=b, caption{EBNF of how a variable can be declared.}]
% <variable> -> (<arithmetic expression> | $\lambda$);
% \end{lstlisting}

% \subsection{Expression}
% \begin{lstlisting}[mathescape, captionpos=b, caption{EBNF of expressions.}]
% <arithmetic expression> -> <variable> (+ | - | *) <variable>;
% \end{lstlisting}

\section{Semantics}
The semantics of a language is the description of what happens when a program is executed.

Seen in table \ref{tab:semantics_aritmethic}, \ref{tab:semantics_boolean} and \ref{tab:semantics_statements} are the exact descriptions of the possible operations in our language. \ref{tab:semantics_aritmethic} describes all arithmetic actions - the more obvious ones are addition, subtraction, multiplication and division (PLUS, MINUS, MULT, DIV) which all look near identical: A statement, s, with two expressions, $v_{1}$ and $v_{2}$ which both are arithmetic as seen by $\rightarrow_{a}$ can be added, subtracted, multiplied or divided with each other. This results in $v$ which again is arithmetic. Furthermore $v$ is the product of the operator used on $v_{1}$ and $v_{2}$. Both modulus and power (MOD, POW) are identical to these operations in procedure. \\
SQRT is a simple rule to allow any arithmetic expression, $v_{1}$ to be squared, where $v$ obviously is $\sqrt{v_{1}}$. \\
The PARENT rule simply states that any arithmetic expression can be parenthesized, allowing chained arithmetic calculations to be performed in the correct order. VAR describes that in a state $s$ a value $v$ be assigned to a variable $x$ allowing variable declaration. NUM allows within a statement $S$ to get the numerical value of a variable $v$ \\

The table \ref{tab:semantics_boolean} holds the rules of boolean operations. Once again a lot of operations look near identical, namely EQUAL1, EQUAL2, NOTEQUAL1, NOTEQUAL2, GREATER1, GREATER2, LESSER1, LESSER2, LEQ1, LEQ2, GEQ1 and GEQ2. The common factor is that these are all comparison expressions, respectively checks for equality, greater than, less than, less or equal to and greater or equal to. Having a $v_{1}$ and $v_{2}$ which are both arithmetic as seen by $\rightarrow_{a}$, we use a boolean evaluation to conclude whether comparison is true (tt) or false (ff). \\
The NOT1, NOT2, AND1, AND2, OR1 and OR2 expressions are similar as well. Arithmetic expressions are tested with some criteria and evaluated to true or false. In the case of NOT1 where the evaluation is true, the evaluation of NOT1 is obviously false as it is not "not", with NOT2 being the opposite case. AND1, AND2, OR1 and OR2 follow same principles. In AND1 and AND2, two expressions need to be true if the entire expression is to be true, while OR1 and OR2 just needs one of two expressions. \\
As with the PARENT rule in table \ref{tab:semantics_aritmethic} any boolean expression can be parenthesized as well as seen in this PARENT rule. \\ \todo{The therminology should be corrected here.}

The table of statement semantics, \ref{tab:semantics_statements} holds rules affecting statements in any way. \\
ASS describes that with a given state and expression ($a, s$), a variable $x$ can be assigned a value $v$. The SKIP rule states that within a state $s$, a skip can occur, leading to a state $s$. COMP allows compositional statements meaning that a series of statements can occur. IFTRUE and IFFALSE allows choosing an appropriate substatement based on some boolean expression within a statement. \\ \todo{Morten: Missing WHILETRUE and WHILEFALSE. Help please.}

\begin{table}[h]
	\begin{tabular}{|l|l|l|}
	\hline
	\emph{Name}			& \emph{Rule}																															& \emph{Notes} \\ \hline
			~			&															~																			& ~ \\
	$[PLUS_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1}+a_{2} \rightarrow_{a} v$ 			& where $v = v_{1}+v_{2}$ \\
			~			&															~																			& ~ \\
	$[MINUS_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1}-a_{2} \rightarrow_{a} v$ 			& where $v = v_{1}-v_{2}$ \\
			~			&															~																			& ~ \\
	$[MULT_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1}*a_{2} \rightarrow_{a} v$ 			& where $v = v_{1}*v_{2}$ \\
			~			&															~																			& ~ \\
	$[DIV_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash {a_{1}}/{a_{2}} \rightarrow_{a} v$ 		& where $v = \frac{v_{1}}{v_{2}}$ \\
			~			&																																		& ~ \\
	$[MOD_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1}\%a_{2} \rightarrow_{a} v$			& where $v = v_{1}\%v_{2}$ \\
			~			&															~																			& ~ \\
	$[POW_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1}\texttt{\^{}}a_{2} \rightarrow_{a} v$	& where $v = v_{1}\texttt{\^{}}v_{2}$ \\
			~			&															~																			& ~ \\
	$[SQRT_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1} \over s \vdash sqrt(a_{1}) \rightarrow_{a} v_{1}$												& where $v = \sqrt{v_{1}}$ \\
			~			&															~																			& ~ \\
	$[PARENT_{BSS}]$	& $s \vdash a_{1} \rightarrow_{a} v_{1} \over s \vdash (a_{1}) \rightarrow_{a} v_{1}$													& ~ \\
			~			&															~																			& ~ \\
	$[NUM_{BSS}]$		& $s \vdash n \rightarrow_{a} v$  if  $\mathcal{N}\llbracket n \rrbracket = v$															& ~ \\
			~			&															~																			& ~ \\
	$[VAR_{BSS}]$		& $s \vdash x \rightarrow_{a} v$  if  $sx = v$														   									& ~ \\
			~			&															~																			& ~ \\
	\hline
	\end{tabular}
	\label{tab:semantics_aritmethic}
	\caption{The semantics of arithmetic operations}
\end{table}

\begin{table}[h]
	\begin{tabular}{|l|l|l|}
	\hline
	\emph{Name}			& \emph{Rule}																															& \emph{Notes} \\ \hline
			~			&															~																			& ~ \\
	$[NOT1_{BSS}]$		& $s \vdash b_{1} \rightarrow_{b} tt \over s \vdash not b_{1} \rightarrow_{b} ff$														& ~ \\
			~			&															~																			& ~ \\
	$[NOT2_{BSS}]$		& $s \vdash b_{1} \rightarrow_{b} ff \over s \vdash not b_{1} \rightarrow_{b} tt$														& ~ \\
			~			&															~																			& ~ \\
	$[EQUAL1_{BSS}]$	& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} equals a_{2} \rightarrow_{b} tt$		& if $v_{1} = v_{2}$ \\
			~			&															~																			& ~ \\
	$[EQUAL2_{BSS}]$	& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} equals a_{2} \rightarrow_{b} ff$		& if $v_{1} \ne v_{2}$ \\
			~			&															~																			& ~ \\
	$[NOTEQUAL1_{BSS}]$	& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} notequals a_{2} \rightarrow_{b} tt$	& if $v_{1}\ne v_{2}$ \\
			~			&															~																			& ~ \\
	$[NOTEQUAL2_{BSS}]$	& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} notequals a_{2} \rightarrow_{b} ff$	& if $v_{1} = v_{2}$ \\
			~			&															~																			& ~ \\
	$[GREATER1_{BSS}]$	& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} < a_{2} \rightarrow_{b} tt$			& if $v_{1} < v_{2}$ \\
			~			&															~																			& ~ \\
	$[GREATER2_{BSS}]$	& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} < a_{2} \rightarrow_{b} ff$			& if $v_{1} \not< v_{2}$ \\
			~			&															~																			& ~ \\
	$[LESSER1_{BSS}]$	& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} > a_{2} \rightarrow_{b} tt$			& if $v_{1} > v_{2}$ \\
			~			&															~																			& ~ \\
	$[LESSER2_{BSS}]$	& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} > a_{2} \rightarrow_{b} ff$			& if $v_{1} \not> v_{2}$ \\
			~			&															~																			& ~ \\
	$[LEQ1_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} >= a_{2} \rightarrow_{b} tt$			& if $v_{1} \leq v_{2}$ \\
			~			&															~																			& ~ \\
	$[LEQ2_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} >= a_{2} \rightarrow_{b} ff$			& if $v_{1} \not\leq v_{2}$ \\
			~			&															~																			& ~ \\
	$[GEQ1_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} <= a_{2} \rightarrow_{b} tt$			& if $v_{1} \geq v_{2}$ \\
			~			&															~																			& ~ \\
	$[GEQ2_{BSS}]$		& $s \vdash a_{1} \rightarrow_{a} v_{1}  s \vdash a_{2} \rightarrow_{a} v_{2} \over s \vdash a_{1} <= a_{2} \rightarrow_{b} ff$			& if $v_{1} \not\geq v_{2}$ \\
			~			&															~																			& ~ \\
	$[PARENT_{BSS}]$	& $s \vdash b_{1} \rightarrow_{b} v_{1} \over s \vdash (b_{1}) \rightarrow_{b} v_{1}$													& ~ \\
			~			&															~																			& ~ \\
	$[AND1_{BSS}]$		& $s \vdash b_{1} \rightarrow_{b} tt  s \vdash b_{2} \rightarrow_{b} tt \over s \vdash b_{1} and b_{2} \rightarrow_{b} tt$				& ~ \\
			~			&															~																			& ~ \\
	$[AND2_{BSS}]$		& $s \vdash b_{i} \rightarrow_{b} ff \over s \vdash b_{1} and b_{2} \rightarrow_{b} ff$													& where $i \in \{1,2\}$ \\
			~			&															~																			& ~ \\
	$[OR1_{BSS}]$		& $s \vdash b_{1} \rightarrow_{b} tt  s \vdash b_{2} \rightarrow_{b} tt \over s \vdash b_{1} or b_{2} \rightarrow_{b} tt$				& ~ \\
			~			&															~																			& ~ \\
	$[OR2_{BSS}]$		& $s \vdash b_{i} \rightarrow_{b} ff \over s \vdash b_{1} or b_{2} \rightarrow_{b} ff$													& ~ \\
			~			&															~																			& ~ \\
	\hline
	\end{tabular}
	\label{tab:semantics_boolean}
	\caption{The semantics of boolean operations}
\end{table}

\begin{table}[h]
	\begin{tabular}{|l|l|l|}
	\hline
	\emph{Name}			& \emph{Rule}																															& \emph{Notes} \\ \hline
			~			&															~																			& ~ \\
	$[ASS_{BSS}]$		& $\langle x := a,s \rangle \rightarrow s[x \mapsto v]$																					& where $s \vdash a \rightarrow_{a} v$ \\
			~			&															~																			& ~ \\
	$[SKIP_{BSS}]$		& $\langle skip, s \rangle \rightarrow s$																								& ~ \\
			~			&															~																			& ~ \\
	$[COMP_{BSS}]$		& $\langle S_{1},s \rangle \rightarrow s''  \langle S_{1},s'' \rangle \rightarrow s'  \over \langle S_{1};S_{2},s \rangle \rightarrow s'$	& ~ \\
			~			&															~																			& ~ \\
	$[IFTRUE_{BSS}]$	& $\langle S_{1},s \rangle \rightarrow s' \over \langle if b do S_{1} else S_{2},s \rangle \rightarrow s'	$							& if $s \vdash b \rightarrow_{b} tt$\\
			~			&															~																			& ~ \\
	$[IFFALSE_{BSS}]$	& $\langle S_{2},s \rangle \rightarrow s' \over \langle if b do S_{1} else S_{2},s \rangle \rightarrow s'	$							& if $s \vdash b \rightarrow_{b} ff$\\
			~			&															~																			& ~ \\
	$[WHILETRUE_{BSS}]$	& $\langle S,s \rangle \rightarrow s'' \langle while b do S,s'' \rangle \rightarrow s' \over \langle while b do S,s \rangle \rightarrow s'	$ & if $s \vdash b \rightarrow_{b} tt$\\
			~			&															~																			& ~ \\
	$[WHILEFALSE_{BSS}]$& $\langle while b do S,s \rangle \rightarrow s if s \vdash b \rightarrow_{b} ff $														& ~ \\
	\hline
	\end{tabular}
	\label{tab:semantics_statements}
	\caption{The semantics of statements}
\end{table}