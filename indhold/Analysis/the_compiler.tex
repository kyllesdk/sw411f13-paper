\chapter{The compiler} \label{chap:the_compiler}
A compiler is a program which translates one language into another. When writing a program to run on any kind of computer, the programmer uses a source language such as Java or C. A computer however only understands the language of binary code, also called machine code. Binary code is in this case the target language reached by translating the source language into the target language. Writing the program in binary code is however not optimal for the programmer as the alphabet of binary consisting of 0 and 1 is hard to understand and use. There are no abstractions as opposed to higher level (abstract) languages where, for example, sensible names for variables can be used for an easier reading.\\
Specific for this project the goal is to translate a high-level language to another high-level language - Namely from our language to the Arduino language. The task of translating a programming language into another can be done using a compiler which is, basically, a translator. The compiler allows the programmer to avoid using the target language. The compiler is therefore responsible for always producing a correct representation of source language in the target language.

\section{The structure of a compiler}
The task of compiling a source language into a target language is not a one step process. The compiler goes through several steps to translate a program in a source language into a target language. Some steps are optional to the task of compiling one language into another.\cite{compiler:structure}\\

\begin{itemize}
	\item The first step a compiler performs is the scanner which prepares the source code for further treatment. This is done by running through the entire program one character at a time. Any unneeded code is removed in this process, for example comments.  Every other part of the code is placed in groupings called tokens. These can for example be integers, identifiers and operators. Any user defined elements is furthermore put into a symbol tree which is accessible throughout the process of compilation. If the user for example has defined that whenever the word ``POWER'' is written in the code of the program, it in fact always refers to the number ``9001'', this would be put into the symbol tree. The result is that whenever ``POWER'' is found in the code, it will be replaced with ``9001''. After the source program has been run through, the output from the scanner is passed on to the parser.
	
	\item The parser analyses the syntax of the code passed on by the scanner. The parser checks that the syntax of the program to be compiled is appropriate to the defined syntax of the source language. If the written code is not proper according to the source language it would not be possible to translate it correctly. As an example, a C parser will return an error if the code states $a + b = c;$ rather than $c = a + b;$ because the syntax is incorrect according to the syntax definition of C. It is important to note that it is still unknown what the variables contain, which is where the type checker takes over.

	\item After the syntax has been verified the type checker deals with the semantics of the source code. The type checker ensures that all operations performed in the code are legal with regard to the source language. To continue the previous example, $c = a + b;$ is syntactically correct. But what has not been mentioned is the content of a, b and c. If a and b are strings, while c is of the type int, the semantics are incorrect and will therefore return an error as the operation does not make sense in the source language. The output of the parser is an abstract syntax tree (AST). \todo{input example of AST from javaCC}

	\item The preparation of the source code is complete and the translation into the target language can be performed correctly. This is done by a translator. The translator translates the generated AST, from the parser, to an executable form. To translate the AST code generation visitors (CodeGenVisitor) are used, which visit the nodes in the AST. There are various different CodeGenVisitors to generate the right low-level language code. The output from the translator is the compiled product of the source code.
\end{itemize}

While this covers the direct compiling process, more optional steps can be used to enhance the compiling process for different purposes.\\

\begin{itemize}
\item An optimizer can be used produce more effective code in the target language. While a piece of code can be optimal in the source language, the target language might have a more efficient formulation for describing the same action than the direct translation would produce. The optimizer locates code which can be optimized and replaces the code with the more efficient model.

\end{itemize}
